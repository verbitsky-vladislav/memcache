- [X]  Создать базовое memcache хранилище через map && mutex
- [ ]  Создать шардированное распределение
  - [X]  Создать фиксированное шардированное распределение данных
  - [ ]  Создать динамическое шардированное распределение данных
    - [ ]  Решить проблему получения индексов шарда при динамическом расширении (% will not working)
      - [ ]  Изучить consistent hashing
      - [ ]
- [ ]  Создать TTL для объектов в мапе
- [ ]  Создать LRU(Least Recently Used)
  Алгоритм управления памятью, который удаляет из памяти те объекты, к которым дольше всего не было обращений
  - [ ]  Определить на каком уровне происходит очистка (шард или base cache)
  - [ ]  Определить при каких условиях происходит очистка
    - [ ]  Как достичь наиболее эффективной очистки
  - [ ]  Использовать map() и двусвязный список для реализации
- [ ]  Если мы добавим приведение comparable типов в ключах, то ускорит ли это получение / запись данных?
- [ ]  Разобраться с тем что такое сериализация данных и поможет ли это нам?

> **Параметры хеширования**: Использование рандомного значения как семени для хеш-функции может помочь избежать коллизий. Однако, стоит подумать о том, как это значение будет обновляться, если кэш станет многопоточным.

Как реализовать SET с шардированием??

Чтобы реализовать метод `Set` для шардированного кэша, следуй этим шагам:

1. **Хеширование ключа**: Начни с вычисления хеш-значения для ключа с использованием хеш-функции, которую ты уже определил. Передай ключ и seed (в данном случае `hash0`) в хеш-функцию. Это позволит получить числовое значение, которое будет использовано для определения индекса шардов.
2. **Определение индекса шарда**: Используй модульное деление, чтобы определить, в какой шард ты будешь помещать значение. Это делается с помощью вычисления `hashValue % numShards`.
3. **Проверка наличия шардов**: Если индекс, полученный в предыдущем шаге, больше или равен текущему количеству шардов, это означает, что необходимо создать новые шарды. В этом случае вызови функцию `createNewShards`, чтобы расширить количество шардов.
4. **Сохранение значения**: Получив индекс шардов, используй его для доступа к соответствующему шару в массиве `shards`. Затем вызови метод `Set` у этого шарда, передавая ему ключ и значение. Это поместит значение в правильный шард, обеспечивая правильное распределение данных.
5. **Обработка ошибок**: Убедись, что в случае ошибок при добавлении значения в шард (например, если шард заполнен или произошла другая ошибка) происходит корректная обработка, например, логирование или возврат сообщения об ошибке.
